\scnsegmentheader{Сегмент. Архитектура ассоциативных семантических компьютеров для ostis-систем}
\begin{scnsubstruct}
	
	\scnheader{ассоциативный семантический компьютер}
	\scnsubset{компьютер с графодинамической ассоциативной памятью}
	\scnidtf{associative semantic computer}
	\scnidtf{sc-компьютер}
	\scnidtf{аппаратно реализованный базовый интерпретатор семантических моделей (sc-моделей) компьютерных систем}
	\scnidtf{аппаратно реализованная ostis-платформа}
	\scnidtf{аппаратный вариант ostis-платформы}
	\scnidtf{ассоциативный семантический компьютер, управляемый знаниями}
	\scnidtf{компьютер с нелинейной структурно перестраиваемой (графодинамической) ассоциативной памятью, переработка информации в которой сводится не к изменению состояния элементов памяти, а к изменению конфигурации связей между ними}
	\scnidtf{универсальный компьютер нового поколения, специально предназначенный для реализации семантически совместимых гибридных интеллектуальных компьютерных систем}
	\scnidtf{универсальный компьютер нового поколения, ориентированный на аппаратную интерпретацию логико-семантических моделей интеллектуальных компьютерных систем}
	\scnidtf{универсальный компьютер нового поколения, ориентированный на аппаратную интерпретацию ostis-систем}
	\scnidtf{ostis-компьютер}
	\scnidtf{компьютер для реализации ostis-систем}
	\scnidtf{компьютер, управляемый знаниями, представленными в SC-коде}
	\scnidtf{компьютер, ориентированный на обработку текстов SC-кода}
	\scnidtf{компьютер, внутренним языком которого является SC-код}
	\scnidtf{компьютер, осуществляющий реализацию sc-памяти и интерпретацию scp-программ}
	\scnidtf{предлагаемый нами компьютер нового поколения, ориентированный на реализацию интеллектуальных компьютерных систем и использующий SC-код в качестве внутреннего языка}
	\scntext{основная цель}{Повысить производительность компьютерных систем, основанных на знаниях, представленных в виде семантических сетей}
	\scnrelfrom{формальная основа решения проблемы}{\scnkeyword{SC-код}}
	\begin{scnsubdividing}
		\scnitem{scp-компьютер}
		\begin{scnindent}
			\scnidtf{sc-компьютер, обеспечивающий интепретацию scp-программ}
			\scnrelfrom{обобщенная модель}{базовая ostis-платформа}
		\end{scnindent}
		\scnitem{sc-компьютер с расширенным набором аппаратно реализуемых sc-агентов}
		\begin{scnindent}
			\scnidtf{sc-компьютер, обеспечивающий интепретацию scp-программ}
			\scnrelfrom{обобщенная модель}{специализированная ostis-платформа}
		\end{scnindent}
	\end{scnsubdividing}
	
	\scnheader{scp-компьютер}
	\scnidtf{минимальная конфигурация аппаратно реализованной ostis-платформы, в рамках которой обеспечивается интерпретация scp-программ}
	\scnidtf{минимальная конфигурация аппаратно реализованной ostis-платформы, в рамках которой аппаратно реализуются только базовые sc-агенты}
	\scnexplanation{В рамках scp-компьютера аппаратно реализуется (1) sc-память, (2) базовые sc-агенты, обеспечивающие интерпретацию scp-программ, (3) элементарные рецепторные sc-агенты, (4) элементарные эффекторные sc-агенты}
	
	\scnheader{ассоциативный семантический компьютер}
	\scnnote{Для уточнения архитектуры \textit{ассоциативных семантических компьютеров} необходимо уточнить:
	\begin{scnitemize}
			\item{Базовую структуру компьютера, и, в частности, его процессоро-памяти;}
			\item{Алфавит элементов, хранимых в процессоро-памяти компьютера;}
			\item{Систему команд, интерпретируемых компьютером;}
			\item{Принципы управления процессом интерпретации указанных команд;}
			\item{Систему микропрограмм, обеспечивающих реализацию принципов управления указанным процессом.}
	\end{scnitemize}}
	\scnnote{Поскольку внутренним языком кодирования информации для \textit{ассоциативного семантического компьютера} является SC-код, то алфавит элементов, хранимых в процессоро-памяти компьютера, совпадает с \textit{Алфавитом SC-кода}. При этом алфавит физически кодируемых  синтаксических меток может быть расширен, например, из соображений производительности, по аналогии с тем, как это делается в программном варианте реализации \textit{ostis-платформы}.}
	\begin{scnindent}
		\begin{scnrelfromlist}{смотрите}
			\scnitem{Предметная область и онтология программных вариантов реализации базового интерпретатора логико-семантических моделей ostis-систем на современных компьютерах}
			\scnitem{Предметная область и онтология внутреннего языка ostis-систем}
		\end{scnrelfromlist}
	\end{scnindent}
	\scnnote{В качестве системы команд для \textit{ассоциативного семантического компьютера} предлагается \textit{Язык SCP}. Таким образом, как уже сказано в указанном параграфе, \textit{Язык SCP} представляет собой ассемблер для \textit{ассоциативного семантического компьютера}.}
	\begin{scnindent}
		\scnrelfrom{смотрите}{Предметная область и онтология Базового языка программирования ostis-систем}
	\end{scnindent}
	\scnnote{Для определения базовой структуры \textit{ассоциативного семантического компьютера} уточним варианты такой структуры, предложенные в работах В.В. Голенкова и В.М. Кузьмицкого. В частности, в работе В.М. Кузьмицкого предложен переход от крупнозернистых архитектур графодинамических машин к мелкозернистым.}
	\begin{scnindent}
		\begin{scnrelfromlist}{источник}
			\scnitem{\scncite{Golenkov1996}}
			\scnitem{\scncite{Kuzmickij2000}}
		\end{scnrelfromlist}
	\end{scnindent}
	
	\scnheader{крупнозернистая архитектура ассоциативного семантического компьютера}
	\scnnote{Модели крупнозернистых архитектур имеют в своем составе параллельно функционирующие модули, обладающие следующими свойствами:
		\begin{scnitemize}
			\item{Каждый модуль имеет строго фиксированное функциональное назначение в рамках архитектуры графодинамической машины в целом (так называемое глобальное функциональное назначение).}
			\item{Каждый модуль имеет относительно большой объем памяти (количество элементов памяти много больше общего количества модулей).}
			\item{Над памятью каждого типа модуля определен свой неэлементарный набор операций, выполняющих некоторые законченные преобразования над достаточно большими фрагментами памяти.}
	\end{scnitemize}}
	\scnnote{Основным формальным отличием для моделей мелкозернистых архитектур выступает иное соотношение между общим количеством модулей и количеством элементов памяти каждого модуля (емкостью памяти модуля), которое стремится к единице, и уровнем сложности операций модели. Соответственно свойствами моделей мелкозернистых архитектур можно считать следующие:
	\begin{scnitemize}
		\item{Для каждого модуля по отдельности может не просматриваться его функциональное назначение в рамках графодинамической машины в целом. Вместе с тем каждый отдельный модуль в конкретный момент времени может иметь некоторое так называемое локальное функциональное назначение, соответствующее множество которых может уже рассматриваться как имеющее определенное так называемое глобальное функциональное назначение в рамках графодинамической машины в целом.}
		\item{бъем (количество элементов) памяти каждого модуля минимален и стремится к единице. Как следствие, общее количество модулей сопоставимо с общим количеством элементов памяти всех модулей.}
		\item{Для каждого модуля (в общем случае) набор операций, выполняемых над его памятью, элементарен и ограничен (конечен), так как воздействует лишь на один элемент (или лишь на несколько элементов) памяти и определяется очевидной ограниченностью (конечностью) семантики интерпретации содержимого элемента графовой памяти графодинамической машины.}
	\end{scnitemize}}
	\begin{scnindent}
		\scnrelfrom{источник}{\scncite{Kuzmickij2000}}
	\end{scnindent}
	\scnnote{Целесообразность перехода от крупнозернистых архитектур к мелкозернистым обусловлена соответствующим увеличением степени потенциального параллелизма в процедурах переработки знаний.}

	\scnheader{ассоциативный семантический компьютер}
	\begin{scnrelfromset}{варианты архитектур}
		\scnitem{Архитектура ассоциативного семантического компьютера на базе фон-Неймановской архитектуры}
		\scnitem{Вариант крупнозернистой архитектуры ассоциативных семантических компьютеров}
		\scnitem{Вариант мелкозернистой архитектуры ассоциативных семантических компьютеров}
	\end{scnrelfromset}

	\scnheader{Архитектура ассоциативного семантического компьютера на базе фон-Неймановской архитектуры}
	\scntext{примечание}{Одним из логичных и наиболее простых с архитектурной точки зрения вариантов аппаратной реализации ostis-платформы является реализация средств хранения конструкций SC-кода и интерпретации scp-программ на аппаратном уровне по аналогии с тем, как это делается в программных вариантах ostis-платформы на базе современных компьютеров. В этом случае общая архитектура компьютера остается фон-Неймановской (с явным выделением отдельного процессорного модуля и отдельного модуля памяти).}
	\begin{scnindent}
		\scnrelfrom{смотрите}{Предметная область и онтология программных вариантов реализации базового интерпретатора логико-семантических моделей ostis-систем на современных компьютерах}
	\end{scnindent}
	\begin{scnrelfromset}{особенности}
		\scnfileitem{Модуль памяти (реализация \textit{sc-памяти}) представляет собой множество ячеек, каждая из которых может хранить некоторый sc-элемент или может быть пустой. Каждая ячейка такой памяти имеет некоторый уникальный внутренний адрес, аналогичный адресу ячеек фон-Неймановской памяти. В то же время, при обработке информации, хранимой в такой памяти, на уровне языка команд (Языка SCP), в отличие от фон-Неймановской памяти адреса ячеек не учитываются, доступ к sc-элементам осуществляется исключительно по связям инцидентности между ними. Исключение составляют некоторые ключевые sc-элементы, набор которых оговаривается отдельно и доступ к которым осуществляется по какому-либо другому идентификатору, например, системному sc-идентификатору или основному sc-идентификатору для какого-либо внешнего языка, но не по адресу. 
			Подразумевается, что если в ячейке хранится некоторый sc-элемент, то в ней хранится информация, характеризующая этот sc-элемент, а именно:
			\begin{scnitemize}
				\item{синтаксическая метка, задающая тип соответствующего sc-элемента;}
				\item{содержимое внутреннего файл ostis-системы или ссылка на внешнюю файловую систему (если хранится внутренний файл ostis-системы);}
				\item{перечень связей инцидентности данного sc-элемента с другими sc-элементами, что фактически означает хранение набора адресов ячеек памяти, соответствующих sc-элементам, инцидентным данному sc-элементу. Конкретный перечень типов хранимых связей может уточняться в зависимости от реализации. Например, по аналогии с тем, как это сделано в программном варианте реализации ostis-платформы, целесообразно хранить в ячейке памяти адрес ячейки, соответствующей первому sc-коннектору, инцидентному соответствующему sc-элементу соответствующим типом инцидентности, а в рамках ячейки, соответствующей данному sc-коннектору хранить адрес ячейки, соответствующей следующему sc-коннектору, инцидентного тому же sc-элементу тем же типом инцидентности и так далее. При таком подходе размер каждой ячейки памяти можно сделать фиксированным.}
				\item{метка блокировки sc-элемента с указанием метки соответствующего процесса;}
				\item{метка уровня доступа и любые другие метки при необходимости.}
		\end{scnitemize}}
		\scnfileitem{Процессорный модуль реализует набор команд, соответствующих \textit{атомарным типам scp-операторов}.}
		\scnfileitem{Для связи с внешней средой вводится \textit{терминальный модуль}, который в общем случае может быть реализован по разному и задачами которого являются:
			\begin{scnitemize}
				\item подготовка (генерация) информации, поступающей из внешней среды для ее последующей ее загрузки в процессорный модуль и модуль памяти;
				\item передача (использование, реализация) информации, подготовленной (полученной, представленной) в процессорном модуле и модуле памяти, во внешнюю среду.
			\end{scnitemize}}
		\begin{scnrelfromlist}{источник}
			\scnitem{\scncite{Golenkov1996}}
			\scnitem{\scncite{Kuzmickij2000}}
		\end{scnrelfromlist}
		\scnfileitem{Для хранения содержимых внутренних файлов ostis-системы большого размера может оказаться целесообразным иметь отдельную файловую память, построенную по фон-Неймановским принципам. Тогда в ячейках семантической памяти, соответствующих таким внутренним файлам ostis-системы, будет хранится не непосредственно их содержимое, а адрес этого файла на файловой памяти.}
		\scnfileitem{Для реализации принципов многоагентной обработки информации, предлагаемых в рамках Технологии OSTIS необходимо реализовать (например, в рамках терминального модуля) подсистему регистрации и обработки событий, которая позволит осуществлять инициирование sc-агентов при возникновении соответствующих событий в памяти.}
		\begin{scnindent}
			\scnrelfrom{смотрите}{Предметная область и онтология решателей задач ostis-систем}
		\end{scnindent}
	\end{scnrelfromset}
	\begin{scnrelfromset}{достоинства}
		\scnfileitem{Относительная простота и невысокая трудоемкость реализации по сравнению с разработкой полноценного варианта процессоро-памяти. В частности, при условии наличия стабильно работающего варианта программной реализации ostis-платформы, в котором хотя бы нижний уровень реализован на языках достаточно низкого уровня, таких как C, для упрощения процесса разработки аппаратной архитектуры возможно использование средств автоматизации перехода от программ на C к описанию на языках описания аппаратуры (HDL --- hardware description language, например, VSDL и Verilog), также известных как \scnqq{C to HDL}. Среди популярных средств и языков этого класса можно отметить LegUp, VHDPlus, SystemC, MyHDL для языка Python и множество других.}
		\begin{scnindent}
		\begin{scnrelfromlist}{источник}
			\scnitem{\scncite{LegUp}}
			\scnitem{\scncite{VHDPlus}}
			\scnitem{\scncite{SystemC}}
			\scnitem{\scncite{MyHDL}}
		\end{scnrelfromlist}
		\end{scnindent}
		\scnfileitem{Простота интеграции с современными компьютерными системами, в частности, можно рассматривать гибридный вариант, при котором \textit{ассоциативный семантический компьютер} реализуется как отдельный подключаемый модуль для современного компьютера, предназначенный для повышения эффективности обработки sc-конструкций.}
	\end{scnrelfromset}
	\scntext{недостаток}{Очевидным ключевым недостатком такого варианта является его ориентация на фон-Неймановскую архитектуру со всеми ее недостатками. Кроме того, в таком варианте по умолчанию на аппаратном уровне не закладывается обеспечение параллельной обработки sc-конструкций. Указанный недостаток частично устраняется в варианте крупнозернистой архитектуры \textit{ассоциативных семантических компьютеров}.}
	
	\scnheader{Вариант крупнозернистой архитектуры ассоциативных семантических компьютеров}
	\scntext{цель}{Целью перехода к крупнозернистой архитектуре \textit{ассоциативных семантических компьютеров} является реализация на аппаратном уровне параллельной обработки sc-конструкций.}
	\begin{scnrelfromset}{особенности}
		\scnfileitem{\textit{ассоциативный семантический компьютер} разделяется на несколько однотипных модулей, устроенных аналогично тому, как строится рассмотренный в предыдущем пункте вариант реализации ассоциативного семантического компьютера на базе фон-Неймановской архитектуры. Такие модули будем называть \scnqq{комбинированными модулями}, поскольку такой модуль имеет свой процессорный модуль и свой модуль памяти (накопительный модуль), отдельно выделяемых общих процессорных модулей не предполагается. Может существовать отдельный общий модуль памяти, в который при необходимости будет записываться информация, которая не поместилась в память конкретного комбинированного модуля.}
		\scnfileitem{По-прежнему выделяется терминальный модуль, обеспечивающий связь системы комбинированных модулей с внешней средой.}
		\scnfileitem{Может отдельно выделяться модуль файловой памяти.}
		\scnfileitem{Число комбинированных модулей относительно невелико (2 --- 16), каждый модуль представляет собой достаточно мощное устройство (фактически --- отдельный \textit{ассоциативный семантический компьютер}) и, соответственно, для решения задач некоторых классов может оказаться достаточно одного комбинированного модуля.}
		\scnfileitem{В то же время в общем случае для решения задачи необходимо задействовать несколько комбинированных модулей. В этом случае обрабатываемая sc-конструкция распределяется между несколькими модулями, для чего создаются sc-узлы-копии, позволяющие обеспечить семантическую связь между фрагментами sc-конструкции, хранящимися в разных комбинированных модулях. Для записи таких конструкций было разработано расширение \textit{SC-кода}, названное \textit{SCD-кодом} (Semantic Code Distibuted), соответственно конструкции такого языка получили название \textit{scd-конструкций}, их элементы --- \textit{scd-элементов} (\textit{scd-узлов}, \textit{scd-дуг}).}
		\begin{scnindent}
			\begin{scnrelfromlist}{источник}
				\scnitem{\scncite{Golenkov1996}}
				\scnitem{\scncite{Kuzmickij2000}}
			\end{scnrelfromlist}
		\end{scnindent}
		\scnfileitem{Аналогично для обработки \textit{scd-конструкций} было разработано расширение \textit{Языка SCP}, названное \textit{Языком SCPD}, учитывающее тот факт, что разные фрагменты обрабатываемой конструкции могут физически храниться в разных комбинированных модулях. При этом предполагается, что все элементы \textit{scd-конструкции}, представляющей \textit{scpd-программу} (программу \textit{Языка SCPD}), должны быть расположены в памяти одного комбинированного модуля, но каждая \textit{scpd-программа} может иметь несколько полных копий в разных комбинированных модулях.}
		\scnfileitem{Для синхронизации параллельных процессов обработки информации комбинированные модули обмениваются сообщениями, которые могут содержать как фрагменты обрабатываемых \textit{scd-конструкций}, так и команды \textit{Языка SCDP}. Соответственно \textit{Язык SCPD} по сравнению с \textit{Языком SCP} имеет дополнительные средства, поддерживающие распределенную переработку графовых конструкций:
			\begin{scnitemize}
				\item{В \textit{Язык SCPD} встроены средства, позволяющие распознавать \scnqq{свой} и \scnqq{чужой} комбинированный модуль, для этого вводятся операторы работы с идентификаторами модулей;}
				\item{Предусмотрена возможность создания копии \textit{scd-элемента} в памяти другого модуля. Для этой цели вводится группа операторов работы с копиями: создание копии \textit{scd-элемента} в указанном модуле, перенос связей элемента-оригинала на копию, склеивание копий элемента, поиск копии данного элемента в заданном модуле и так далее;}
				\item{Предусматривается возможность явного удаленного вызова \textit{scpd-программы} в указанном процессорном модуле. Для параллельного запуска одинаковых процессов, выполняющихся в разных процессорных модулях, предусмотрены операторы, запускающие программу на выполнение в модулях из указанного списка.}
				\item{Имеются средства межпроцессной и внутрипроцессной синхронизации: операторы формирования сообщения, операторы ожидания сообщения, операторы перевода процесса в режим ожидания завершения выполнения распределенно выполняющихся операторов, операторы ожидания завершения выполнения всех распределенно выполняющихся операторов.}
		\end{scnitemize}}
	\begin{scnindent}
		\begin{scnrelfromlist}{источник}
			\scnitem{\scncite{Golenkov1996}}
			\scnitem{\scncite{Kuzmickij2000}}
		\end{scnrelfromlist}
	\end{scnindent}
		\scnfileitem{Для обмена сообщениями каждый комбинированный модуль имеет соответствующие подмодули, позволяющие отправлять и принимать сообщения, а также буфер сообщений для хранения очереди полученных сообщений, ожидающих обработки и сообщений, ожидающих отправки.}
		\scnfileitem{Для интерпретации \textit{scpd-программ} разрабатывается семейство микропрограмм на языке, который в общем случае зависит от выбранных аппаратных компонентов, из которых строятся комбинированные модули.}
	\end{scnrelfromset}
	\scnnote{К описанному варианту реализации \textit{ассоциативных семантических компьютеров} с крупнозернистой архитектурой относится и упомянутая ранее мультитранспьютерная реализация. В основу указанной реализация были положены ПК IBM PC 386 (486, Pentium) и 8 транспьютеров T805.}
	\begin{scnindent}
		\begin{scnrelfromlist}{источник}
			\scnitem{\scncite{Golenkov1994g}}
			\scnitem{\scncite{Golenkov1996}}
		\end{scnrelfromlist}
	\end{scnindent}
	\scnrelfrom{рисунок}{Рисунок. Вариант реализации \textit{ассоциативных семантических компьютеров} с крупнозернистой архитектурой на 8 транспьютерах}
	\scntext{достоинство}{Основным достоинством крупнозернистой архитектуры \textit{ассоциативных семантических компьютеров} является ориентация на аппаратную поддержку параллельной обработки конструкций \textit{SC-кода}.}
	\begin{scnrelfromset}{недостатки}
		\scnfileitem{Каждый комбинированный модуль строится по принципам \textit{машины фон-Неймана}, соответственно, ее недостатки в полной мере не устраняются.}
		\scnfileitem{Несмотря на сохранение общих принципов \textit{SC-кода} и \textit{Языка SCP}, распределенное хранение и обработка sc-конструкций требует разработки отдельных языковых средств, таких как \textit{SCD-код} и \textit{Язык SCPD}, и их поддержки на базе выбранной аппаратной архитектуры. Кроме того, как видно и рассмотренных выше принципов \textit{Языка SCPD}, при разработке \textit{scpd-программ} необходимо явно учитывать тот факт, что обработка выполняется распределенно.}
	\end{scnrelfromset}
	
	\scnheader{Рисунок. Вариант реализации \textit{ассоциативных семантических компьютеров} с крупнозернистой архитектурой на 8 транспьютерах}
	\scneqimage{Contents/part_platform/src/images/coarse-grained architecture.pdf}
	\scnnote{На рисунке схематично показан такой вариант реализации на 8 транспьютерах, где каждый транспьютер одновременно выполняет роль узла коммутации (УК) и процессорного модуля (ПМ) или накопительного модуля (НМ). Вся система при этом взаимодействует с внешней средой посредством терминального модуля (ТМ).}
	
	\scnheader{Вариант мелкозернистой архитектуры ассоциативных семантических компьютеров}
	\scnnote{Целесообразность перехода от крупнозернистых архитектур к мелкозернистым обусловлена  соответствующим увеличением степени потенциального параллелизма в процедурах переработки знаний. При этом максимально возможный параллелизм, очевидно, будет иметь место при предельной реализации мелкозернистых архитектур, в которых один структурный модуль процессоро-памяти будет соответствовать одному элементу памяти, то есть в нашем случае --- одному sc-элементу.}
	\begin{scnrelfromset}{принципы, лежащие в основе}
		\scnfileitem{Процессоро-память \textit{ассоциативного семантического компьютера} состоит из однотипных модулей, которые будем называть процессорными элементами sc-памяти или просто \textit{процессорными элементами}. Каждый \textit{процессорный элемент} соответствует одному sc-элементу (хранит один sc-элемент). При этом в каждый момент времени каждый \textit{процессорный элемент} может быть пустым (не хранить никакой sc-элемент) или заполненным, то есть иметь взаимно однозначно соответствующий ему хранимый sc-элемент. На физическом уровне для описания этого факта вводится соответствующий признак, имеющим два значения. Таким образом, каждый \textit{процессорный элемент} \scnqq{отвечает} только за один sc-элемент и, в отличие от крупнозернистого варианта архитектуры \textit{ассоциативного семантического компьютера}, \uline{задача не может быть решена} \uline{одним \textit{процессорным элементом}} и количество таких \textit{процессорных элементов} достаточно велико (соответствует максимальному возможному числу sc-элементов, хранимых в базе знаний некоторой ostis-системы). Опыт разработки прикладных ostis-систем показывает, что в среднем число sc-элементов в базе знаний такой ostis-системы составляет от нескольких сотен тысяч до нескольких миллионов. Ситуация, когда в рамках процессоро-памяти необходимо представить sc-конструкцию, число элементов которой больше числа \textit{процессорных элементов} на данный момент не рассматривается и требует дополнительного исследования.}
		\scnfileitem{Каждый \textit{процессорный элемент} (по аналогии с ячейкой памяти в случае реализации \textit{ассоциативного семантического компьютера} на фон-Неймановской архитектуре) имеет некоторый уникальный внутренний идентификатор --- \textit{\uline{адрес} процессорного элемента}. Адреса \textit{процессорных элементов}, в отличие от адресов ячеек фон-Неймановской памяти, \uline{не обеспечивают непосредственный доступ} к \textit{процессорным элементам}, а позволяют однозначно \uline{идентифицировать} процессорный элемент при обмене сообщениями согласно рассмотренным принципам.}
		\scnfileitem{Каждый процессорный элемент имеет память, в которой хранится
			\begin{scnitemize}
				\item{синтаксическая метка, задающая тип соответствующего sc-элемента;}
				\item{содержимое внутреннего файла ostis-системы или ссылка на внешнюю файловую систему (если данный процессорный элемент соответствует внутреннему файлу ostis-системы);}
				\item{перечень логических связей данного процессорного элемента с другими, то есть перечень адресов процессорных элементов, связанных с данным процессорным элементом \textit{логическими каналами связи} с указанием типа связи;}
				\item{метка блокировки sc-элементов с указанием метки соответствующего процесса;}
				\item{другие метки при необходимости (например, метки уровня доступа к хранимому sc-элементу);}
				\item{волновые микропрограммы, выполняемые данным процессорным элементом в данный момент, и временные данные для этих микропрограмм, а также очередь микропрограмм при необходимости.}
		\end{scnitemize}}
		\scnfileitem{Процессорные элементы связаны между собой двумя типами каналов связи --- \textit{физическими каналами связи} и \textit{логическими каналами связи}.}
		\begin{scnindent}		
			\begin{scnrelfromlist}{примечание}
				\scnfileitem{В общем случае число \textit{физических каналов связи} у каждого \textit{процессорного элемента} может быть произвольным, кроме того теоретически \textit{физические каналы связи} между процессорными элементами могут перестраиваться (перекоммутироваться) с течением времени, например, с целью оптимизации времени передачи сообщений между процессорными элементами. Конфигурация \textit{физических каналов связи} не учитывается на уровне логической обработки знаний, как на уровне Языка SCP, так и на уровне языка микропрограмм, обеспечивающих интерпретацию команд Языка SCP, то есть \textit{scp-операторов}. Для упрощения в рамках данной работы будем рассматривать вариант физической реализации sc-памяти, в котором каждый процессорный элемент имеет фиксированное и одинаковое для всех процессорных элементов число \textit{физических каналов связи} (N), при этом конфигурация таких каналов связи с течением времени не меняется. Очевидно, что минимальным значением N является 2, в этом случае мы получим линейную цепочку \textit{процессорных элементов}. При N равном 4 мы получим двумерную \scnqq{матрицу} \textit{процессорных элементов}, При N равном 6 --- трехмерную \scnqq{матрицу} \textit{процессорных элементов} и так далее. Будем называть \scnqq{смежными} \textit{процессорные элементы}, непосредственно связанные \textit{физическим каналом связи}.}
				\scnfileitem{В таком случае можно сказать, что каждый процессорный элемент имеет свой \scnqq{адрес} (уникальный идентификатор) в некотором многомерном пространстве, число измерений (признаков) которого определяется числом N \textit{физических каналов связи}, связанных с одним \textit{процессорным элементом}. В приведенных выше примерах размерность такого пространства равна N/2, что позволяет предположить, что число N целесообразно делать четным.}
				\scnfileitem{Каждый \textit{физический канал связи} и каждый \textit{логический канал связи}, таким образом, задается парой \textit{адресов процессорных элементов}.}
				\scnfileitem{\textit{логические каналы связи} между процессорными элементами формируются динамически и соответствуют \textit{связям инцидентности} между sc-элементами. Таким образом, \textit{логические каналы связи} могут описывать два типа связей инцидентности --- \textit{инцидентность обозначений sc-пар с их компонентами} и \textit{инцидентность обозначений ориентированных sc-пар с их вторыми компонентами}. При этом конфигурация \textit{логических каналов связи} в общем случае никак не связана с конфигурацией \textit{физических каналов связи} --- инцидентные sc-элементы могут физически храниться в процессорных элементах, не являющихся смежными. В тоже время очевидно, что в общем случае некоторые \textit{физические каналы связи} могут соответствовать логическим.}
				\begin{scnindent}
					\scnrelfrom{смотрите}{Предметная область и онтология программных вариантов реализации базового интерпретатора логико-семантических моделей ostis-систем на современных компьютерах}
				\end{scnindent}
				\scnfileitem{Кроме связей инцидентности \textit{логические каналы связи} могут соответствовать и другим типам связей между sc-элементами, по аналогии с тем, как это сделано в программном варианте реализации ostis-платформы. Например, для упрощения реализации алгоритмов поиска в базе знаний и уменьшения объема памяти, которым должен обладать каждый \textit{процессорный элемент}, целесообразно хранить в памяти процессорного элемента адрес только первого sc-коннектора, инцидентного соответствующему sc-элементу соответствующим типом инцидентности, а в рамках процессорного элемента, соответствующего данному sc-коннектору, адрес следующего sc-коннектора, инцидентного тому же sc-элементу тем же типом инцидентности и так далее. При таком подходе количество памяти процессорного элемента, хранящей логические связи между процессорными элементами, можно сделать фиксированным.}
				\begin{scnindent}
					\scnrelfrom{смотрите}{Предметная область и онтология программных вариантов реализации базового интерпретатора логико-семантических моделей ostis-систем на современных компьютерах}
				\end{scnindent}
			\end{scnrelfromlist}
		\end{scnindent}
		\scnfileitem{Каждый процессорный элемент может отправлять сообщения (микропрограммы) другим процессорным элементам и принимать сообщения от других процессорных элементов по \textit{логическим каналам связи} и имеет соответствующие рецепторно-эффекторные подмодули. На физическом уровне передача сообщений осуществляется, в свою очередь, по \textit{физическим каналам связи}, конфигурация которых, как было сказано выше, фиксируется и в общем случае не зависит от конфигурации логических каналов связи.}
		\scnfileitem{Таким образом, процессорные элементы формируют однородную процессоро-память, в которой нет отдельно выделяемых модулей, предназначенных только для хранения информации и отдельно выделяемых модулей, предназначенных только для ее обработки.}
		\scnfileitem{Для связи такой процессоро-памяти с внешней средой вводится \textit{терминальный модуль}, который в общем случае может быть реализован по разному и задачами которого являются:
			\begin{scnitemize}
				\item{подготовка (генерация) информации, поступающей из внешней среды для ее последующей загрузки в процессорные модули;}
				\item{передача (использование, реализация) информации, подготовленной (полученной, представленной) в процессорных модулях, во внешнюю среду.}
			\end{scnitemize}}
		\scnfileitem{Для хранения содержимых внутренних файлов ostis-системы большого размера может оказаться целесообразным иметь отдельную файловую память, связанную с процессоро-памятью и построенную по традиционным фон-Неймановским принципам. Это обусловлено тем, что основная цель построения процессоро-памяти -- обеспечение как можно большей параллельности при обработке конструкций SC-кода, в случае же с хранением и обработкой содержимых внутренних файлов ostis-системы, которые по определению являются внешними по отношению к SC-коду информационными конструкциями, целесообразно использовать современные традиционные подходы.}
	\end{scnrelfromset}
	\scnnote{Перечисленные принципы позволяют сформулировать ключевую особенность обработки информации, хранимой в рамках такой процессоро-памяти. В отличие от архитектуры фон-Неймана (и других архитектур, разработанных примерно в то же время, например, Гарвардской архитектуры) и даже от \textit{программного варианта ostis-платформы} в предлагаемой архитектуре процессоро-памяти \uline{отсутствует общая память}, доступная для всех модулей, осуществляющих обработку информации. Благодаря этому значительно упрощается параллельная обработка информации, однако усложняется реализации набора микропрограмм интерпретации команд обработки информации в такой памяти, поскольку каждый процессорный элемент становится очень \scnqq{близоруким} и \scnqq{видит} только те процессорные элементы, которые связаны с ним \textit{логическими каналами связи}.}
	\scnnote{Язык описания микропрограмм интерпретации команд \textit{ассоциативного семантического компьютера} не может быть построен как традиционный язык программирования, например, процедурного типа, поскольку все такие языки предполагают возможность непосредственного адресного или ассоциативного доступа к произвольным элементам памяти. Предлагаемый язык описания микропрограмм предлагается строить по принципам \textit{волновых языков программирования} и инсерционного программирования.}
	\begin{scnindent}
		\begin{scnrelfromlist}{источник}
			\scnitem{\scncite{Sapatyj1986}}
			\scnitem{\scncite{Moldovan1985}}
			\scnitem{\scncite{Letichevskij2003}}
			\scnitem{\scncite{Letichevskij2012}}
		\end{scnrelfromlist}
	\end{scnindent}
	
	\scnheader{волновой язык программирования}
	\scnnote{В рамках такого языка микропрограмм выделяется два типа волн:
		\begin{scnitemize}
			\item{Волны, передаваемые только по \textit{логическим каналам связи} (например, при поиске инцидентных sc-элементов).}
			\item{Волны, передаваемые по всем каналам связи (например, при создании новых логических каналов связи, то есть при генерации новых sc-элементов).}
	\end{scnitemize}}

	\scnheader{Вариант мелкозернистой архитектуры ассоциативных семантических компьютеров}
	\begin{scnrelfromset}{принципы интерпретации команд}
		\scnfileitem{Каждый \textit{процессорный элемент} может интерпретировать некоторый ограниченный набор микропрограмм. С учетом того, что один процессорный элемент соответствует одному sc-элементу, то множество операций, связанных с преобразованием данного sc-элемента, очень ограничено (сгенерировать sc-элемент указанного типа, удалить sc-элемент, изменить содержимое sc-файла, установить или снять метку блокировки и так далее). Таким образом, важной задачей процессорного элемента будет формирование сообщений для других процессорных элементов и их отправка.}
		\scnfileitem{Каждый процессорный элемент может порождать и хранить в памяти временные данные для микропрограмм. Предполагается, что объем памяти, имеющейся в распоряжении процессорного элемента, достаточен для представления всех необходимых данных для возможного набора микропрограмм, поскольку такие микропрограммы достаточно просты (см. предыдущий принцип). В случае, если по каким-либо причинам переполнение все же происходит, то могут использоваться различные подходы.}
		\begin{scnindent}
			\scnrelfrom{источник}{\scncite{Kuzmickij2000}}
		\end{scnindent}
		\scnfileitem{Каждый процессорный элемент может сформировать микропрограмму и отправить ее в виде волнового сообщения для выполнения другими процессорными элементами. Передача сообщений происходит по физическим каналам связи. Поскольку конфигурация физических каналов связи в общем случае не связана конфигурацией логических каналов связи, то каждый процессорный элемент самостоятельно принимает решение о необходимости выполнения микропрограммы и передачи ее дальше. Здесь можно провести аналогию с волновым алгоритмом поиска пути в графе (вариант поиска в ширину).}
		\scnfileitem{Часто процессорные элементы будут не выполнять микропрограмму, а передавать ее дальше, таким образом, сами процессорные элементы выполняют также и роль коммутационных элементов, при этом в общем случае каждый процессорный элемент может входить в произвольное число маршрутов при передаче сообщений по логическим каналам связи между процессорными элементами.}
		\scnfileitem{Как и в случае с крупнозернистой архитектурой, у каждого процессорного элемента есть очередь микропрограмм, подлежащих выполнению (входящих сообщений), и очередь микропрограмм, подлежащих отправке (выходящих сообщений). При этом в рамках каждого процессорного элемента также можно говорить о возможности параллельного выполнения каких-либо операций (например, формирование выходящих сообщений и обработку текущего хранимого sc-элемента).}
	\end{scnrelfromset}
	
	\scnheader{микропрограмма}
	\scnsuperset{микропрограмма по изменению хранимого sc-элемента}
	\begin{scnindent}
		\scnnote{
			\begin{scnitemize}
				\item Выполнить указанное преобразование содержимого данного sc-узла;
				\item Изменить метку типа sc-элемента (если такое изменение не противоречит \textit{Синтаксису SC-кода});
				\item Заменить блокировку данного sc-элемента для указанного процесса (в том числе, снять метку);
				\item Удалить sc-элемент.
		\end{scnitemize}}
	\end{scnindent}
	\scnsuperset{микропрограмма по обработке sc-элементов, хранимых в других (не обязательно смежных) процессорных элементах)}
	\begin{scnindent}
		\scnnote{
			\begin{scnitemize}
			\item Сгенерировать инцидентный sc-коннектор (и новый \textit{логический канал связи}), возможно, вместе со смежным sc-элементом;
			\item Сгенерировать оба или один sc-элемент, соединяемые данным sc-коннектором;
			\item Найти все sc-коннекторы (то есть адреса соответствующих им процессорных элементов) указанного типа, инцидентные данному sc-элементу указанным типом инцидентности;
			\item Найти sc-узлы, инцидентные данному sc-коннектору.
		\end{scnitemize}}
	\end{scnindent}
	\scnsuperset{микропрограммы по управлению процессами выполнения других микропрограмм}
	\begin{scnindent}
		\scnnote{
			\begin{scnitemize}
				\item Переслать указанную микропрограмму для исполнения из данного процессорного элемента по всем \uline{указанным} каналам (инцидентным sc-коннекторам указываемого типа) всем \uline{смежным} sc-элементам указываемого типа;
				\item Дождаться выполнения микропрограмм указанного типа, порожденных указанным процессорным элементом и результат их выполнения передать процессорному элементу, запросившему соответствующую информацию.
		\end{scnitemize}}
	\end{scnindent}
	\scnnote{Очевидно, что при решении конкретной задачи указанные микропрограммы могут комбинироваться в более сложные микропрограммы. Приведенная иерархия на данный момент не является полной и требует дальнейшего уточнения.}
	
	\scnheader{Вариант мелкозернистой архитектуры ассоциативных семантических компьютеров}
	\scnrelfrom{иерархия языков программирования}{Иерархия языков программирования для мелкозернистой архитектуры ассоциативных семантических компьютеров}
	\begin{scnindent}
		\begin{scneqtoset}
			\scnfileitem{Язык SCP, не зависящий от реализации ostis-платформы, на котором пишутся программы sc-агентов обработки знаний. Язык SCP является \scnqq{водоразделом} между платформенно-зависимой частью и платформенно-независимой частью ostis-системы, таким образом, он является самым низкоуровневым языком среди всех возможных платформенно-независимых языков, и одновременно языком высокого уровня с точки зрения ostis-платформы.}
			\scnfileitem{Язык микропрограмм, которыми обмениваются процессорные элементы между собой, и которые исполняются этими процессорными элементами. Фактически на этом языке разрабатывается интерпретатор Языка SCP. Важно отметить, что язык микропрограмм ориентирован на передачу сообщений по \textit{логическим каналам связи} и не учитывает конфигурацию \textit{физических каналов связи}. Для этого вводится еще один язык более низкого уровня.}
			\scnfileitem{Язык для записи программ управления процессами обмена сообщениями (микропрограммами).}
			\begin{scnindent}
				\scnnote{Введение такого языка необходимо, поскольку, как было сказано, сам по себе язык микропрограмм не учитывает 
					\begin{scnitemize}
						\item Конфигурацию физических каналов связи. Таким образом, при отправке сообщения по логическому каналу связи необходимо сформировать необходимое число сообщений в зависимости от числа имеющихся физических каналов связи, осуществить кодирование передаваемого сообщения для передачи по физическому каналу связи, передать сообщение с учетом того, что один и тот же физический канал связи может входить в общем случае в произвольное число маршрутов между процессорными элементами, осуществить декодирование сообщения на принимающем процессорном элементе. Все эти задачи требуют разработки соответствующих программ;
						\item Организацию очереди входящих и выходящих сообщений внутри \textit{процессорного элемента}, добавление сообщений в очередь, извлечение сообщений из очереди для выполнения и так далее.
				\end{scnitemize}}
			\end{scnindent}
		\end{scneqtoset}
	\end{scnindent}
	\begin{scnrelfromset}{достоинства}
		\scnfileitem{В рамках предложенной мелкозернистой архитектуры, в отличие от крупнозернистой, нет необходимости создания копий sc-элементов, и разработки специальных языков кодирования для полученных конструкций, таких как \textit{SCD-код}, поскольку каждый процессорный элемент хранит один атомарный фрагмент всей хранимой sc-конструкции и число логических связей с другими процессорными элементами не ограничено.}
		\scnfileitem{Приведенная явно выделяемая иерархия языков программирования позволяет исключить на уровне разработки пользовательских программ (на \textit{Языке SCP} и языков более высокого уровня на его основе) необходимость учитывать факт распределенного хранения sc-конструкций и вообще принципы организации ostis-платформы. Другими словами, не требуется разработка таких языков, как \textit{Язык SCPD}.}
		\scnfileitem{Расширяемость архитектуры позволяет легко наращивать число процессорных элементов без существенного снижения производительности, поскольку в предложенной архитектуре нет явно выделяемых процессорных модулей и накопительных модулей, соответственно исключается необходимость передачи информации между такими модулями, кроме того процессорный модуль перестает быть разделяемым ресурсом для большого числа одновременно выполняемых процессов. Все перечисленное позволит в конечном итоге решить проблему, известную как проблема \scnqq{бутылочного горлышка} архитектуры фон-Неймана.}
		\begin{scnindent}
			\scnrelfrom{источник}{\scncite{Backus1978}}
		\end{scnindent}
		\scnfileitem{Ключевым достоинством предложенной мелкозернистой архитектуры является ее ориентация на максимально возможную поддержку параллельной обработки информации на аппаратном уровне и в конечном итоге возможность реализации \uline{любых} моделей параллелизма с учетом решаемой задачи. В подтверждение данного тезиса можно привести теорию А-систем, описанную в работе В. Е. Котова и А. С. Нариньяни. По словам самих авторов, данное понятие стоит трактовать как универсальную модель для некоторого класса параллельных систем, которая требует уточнения в случае конкретных реализаций. В частности, в рамках данной теории выделяются процессорные элементы, активация/деактивация которых осуществляется посредством так называемой спусковой функции, принимающей значения 0 и 1. Понятно, что в конкретной реализации в качестве такой функции может быть использован любой признак, имеющий значения истина и ложь, указывающий на то, что тот или процессорный элемент должен быть активирован в следующий момент времени. Авторами показана возможность формализации на основе данной модели любых параллельных алгоритмов, рассмотрена возможность сведения таких алгоритмов к последовательным, варианты синхронизации в рамках такой модели.}
		\begin{scnindent}
			\scnrelfrom{источник}{\scncite{Kotov1966}}
			\scnnote{Можно провести очевидную параллель между А-системами и предложенной мелкозернистой архитектурой \textit{ассоциативных семантических компьютеров} с учетом наличия волнового языка микропрограммирования:
			\begin{scnitemize}
				\item Процессорным элементам из теории А-систем соответствуют \textit{процессорные элементы} процессоро-памяти;
				\item В роли спусковых функций для процессорных элементов выступают микропрограммы, передаваемые волнами от одного процессорного элемента к другому и, соответственно, активизирующие деятельность процессорных элементов.
			\end{scnitemize}
		Стоит отметить, что несмотря на то, что рассмотренная работа по теории А-систем известна уже более полувека, авторам данной главы не удалось найти попытки реализовать идеи этой теории в аппаратном варианте. На наш взгляд, это обусловлено тем, что уровень развития микроэлектроники на тот момент не соответствовал необходимым для реализации теории А-систем требованиям.}
		\end{scnindent}
	\end{scnrelfromset}
	\scntext{недостаток}{Вместе с перечисленными достоинствами можно выделить ключевой недостаток предложенного мелкозернистого варианта архитектуры \textit{ассоциативных семантических компьютеров}, который заключается в сильной зависимости быстродействия процессоро-памяти от времени передачи волновых микропрограмм от одного процессорного элемента к другому. При этом, поскольку на логическом уровне передача сообщений осуществляется по \textit{логическим каналам связи}, а реально --- по \textit{физическим каналам связи}, то быстродействие процессоро-памяти будет зависеть от того, насколько близко соответствует конфигурация \textit{логических каналов связи} конфигурации \textit{физических каналов связи}. Очевидно, что в общем случае взаимно однозначное соответствие этих конфигураций невозможно, поскольку число \textit{физических каналов связи}, инцидентных заданному процессорному элементу, ограничено в отличие от числа \textit{логических каналов связи}.}
	\begin{scnindent}
		\begin{scnrelfromset}{варианты оптимизации}
			\scnfileitem{При записи (\scnqq{укладке}) sc-конструкции в процессоро-память (в особенности в случае достаточно больших sc-конструкций) можно учитывать \uline{семантику} записываемых фрагментов, и записывать их таким образом, чтобы те sc-элементы, сообщение к которым будет передаваться от данного sc-элемента с большей вероятностью, находились физически ближе к данному sc-элементу. Так, например, можно учитывать денотационную семантику scp-операторов поиска, которые ориентированы на обработку \textit{трехэлементных sc-конструкций} и \textit{пятиэлементных sc-конструкций}, а также хранить sc-элементы, инцидентные заданному sc-коннектору по возможности ближе к нему.}
			\scnfileitem{Если число логических связей между элементами sc-конструкции не превышает числа доступных физических каналов связи процессорного элемента и sc-граф является планарным (хоть sc-граф не является классическим графом, можно говорить о его планарности по аналогии с планарностью классических графов), то возможна запись sc-конструкции в процессоро-память таким образом, чтобы конфигурация \textit{логических каналов связи} взаимно однозначно соответствовала какому-то подмножеству физических каналов связи. Таким образом, актуальной является разработка алгоритмов оптимальной \scnqq{укладки} sc-графов в процессоро-память для обеспечения последующей эффективности передачи сообщений между процессорными элементами.}
			\scnfileitem{Поскольку конфигурация \textit{логических каналов связи} меняется в процессе обработки sc-конструкций, то целесообразно говорить также о разработке алгоритмов переразмещения (\scnqq{дефрагментации}) уже записанной в процессоро-память sc-конструкции с целью обеспечения последующей эффективности передачи сообщений. Такое переразмещение может выполняться, например, по расписанию в период, когда процессоро-память не используется для решения других задач.}
			\scnfileitem{Кроме того, при наличии аппаратной возможности может выполняться также перекоммутация \textit{физических каналов связи} с целью приближения их конфигурации к конфигурации \textit{логических каналов связи}.}
		\end{scnrelfromset}
	\end{scnindent}
	\scntext{пример}{Пример оптимального варианта записи простейшей пятиэлементной sc-конструкции в предлагаемую процессоро-память}
	\begin{scnindent}
		\scnrelfrom{описание примера}{\scnfileimage[20em]{Contents/part_platform/src/images/incidence example.pdf}}
		\begin{scnindent}
			\scniselement{sc.g-текст}
			\scnnote{Граф инцидентности для \textit{пятиэлементной sc-конструкции}, который позволяет свести sc-конструкцию к классическому графу с двумя типами связей. Для наглядности синтаксические типы соответствующих sc-элементов на рисунке не показаны.}
		\end{scnindent}
		\scntext{пример}{Пример соответствующей пятиэлементной sc-конструкции}
		\begin{scnindent}
			\scnrelfrom{описание примера}{\scnfileimage[20em]{Contents/part_platform/src/images/computer graph1.png}}
		\end{scnindent}
		\scntext{пример}{Пример укладки sc-конструкции в процессоро-память}
		\begin{scnindent}
			\scnrelfrom{описание примера}{\scnfileimage[20em]{Contents/part_platform/src/images/fine-grained architecture.pdf}}
			\scnnote{На рисунке показан один из возможных оптимальных вариантов записи полученного графа инцидентности в процессоро-память. Пунктирными линиями показаны \textit{физические каналы связи} между процессорными элементами, сплошными --- \textit{физические каналы связи}, соответствующие \textit{логическим каналам связи}. Отметим, что элемент \textbf{\textit{R1}} целесообразно записать в \textit{процессорный элемент}, соседний с \textit{процессорным элементом}, хранящим элемент \textbf{\textit{e1}} или элемент \textbf{\textit{e2}}, как и показано на рисунке. Благодаря этому процессорные элементы, хранящие указанные sc-элементы, оказываются непосредственно связаны \textit{физическим каналом связи}, что упрощает коммуникацию в случае рассылки сообщений по \textit{физическим каналам связи} без учета \textit{логических каналов связи}.}
		\end{scnindent}
	\end{scnindent}
	
	\bigskip
\end{scnsubstruct}
\scnsourcecomment{Завершили \scnqqi{Сегмент. Архитектура ассоциативных семантических компьютеров для ostis-систем}}

